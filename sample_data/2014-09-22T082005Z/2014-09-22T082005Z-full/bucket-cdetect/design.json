[{"controllers": {"compact": "/pools/default/buckets/cdetect/ddocs/_design%2Fdev_conflict/controller/compactView", "setUpdateMinChanges": "/pools/default/buckets/cdetect/ddocs/_design%2Fdev_conflict/controller/setUpdateMinChanges"}, "doc": {"json": {"views": {"conflict": {"map": "function (doc, meta) {\n  var handle\n  if(doc.type === \"user\") {\n    emit(meta.id, [\"$isSource\", doc.email, doc.twitter]);\n  } else {\n    handle = meta.id.split(\":\")[1]\n    emit(doc.id, [handle])\n  }\n}", "reduce": "function (keys, values, rereduce) {\n  var groups = {};\n  var k;\n  if(rereduce) {\n    // values now contains groups\n    // { values: [\"jj\"], key: \"main3\", main: [\"joel@basho.com\", \"joeljacobson\"] }\n    // we need to merge them to further process them\n    values.forEach(function(e) {\n      if(!groups[e.key]) {\n        // nothing to merge\n        groups[e.key] = e;\n      } else {\n        groups[e.key].key = e.key;\n        // merge the values, there shouldn't be duplicates\n        group.values.concat(e.values);\n        // main is either null or the same\n        groups[e.key].main = groups[e.key].main || e.main\n        // merge the missmatch and matched counts\n        groups[e.key].miss += e.miss\n        groups[e.key].matched += e.matched\n      }\n    })\n  } else {\n    // Create the groups acording to the keys\n    \n    // The groups look like this:\n    // { values: [\"jj\"], key: \"main3\", main: [\"joel@basho.com\", \"joeljacobson\"] }\n    // in case the view is queried in a grouped way there will only be one key\n    // if they are queried un grouped ther will be N\n    var ck;\n    var group;\n    for(k = 0; k < keys.length; k++) {\n      // process the keys in groups\n      if(keys[k] != ck) {\n        ck = keys[k];\n        groups[ck] = {values: [], key: ck, main: null, miss: 0, matched: 0};\n        group = groups[ck];\n      }\n      if(values[k][0] == \"$isSource\"){\n        values[k].shift();\n        group.main = values[k];\n      } else {\n        group.values.push(values[k][0]);      \n      }\n    }\n  }\n  \n  // now reduce the groups down to the missmatches\n  // anytime there is no missmatch nothing needs to be stored, the end result is \n  // and index which contains just the missmatches globally. Depending on the\n  // number of missmatches it's probably a good idea to query it grouped and paged\n  // if you expect many.\n  \n  // The result is a structure like this:\n  // {\"values\":[],\"key\":\"main1\",\"main\":[\"philipp.fehre@gmail.com\",\"ischi\"],\"miss\":0,\"matched\":1,\"missmatches\":1}\n  // \n  // values: indicate all references which should not be present because they are not present in the main document\n  // key: the key of the main document\n  // main: all the references that were checked, if main is null the main document is missing\n  // missmatches: the number if incorrect references, either missing or wrong\n  \n  // miss: the number of times a refence key was not matched in the main (internal)\n  // matched: the number of times a refece key was matched to the main (internal)\n\n  var curr;\n  var res = [];\n  var miss;\n  var matched;\n      \n  for(k in groups) {\n    \n    curr = groups[k];\n    \n    if(!curr.main) {\n      // the main document is missing, needs to be checked!\n      curr.missmatches = \"all\";\n      res.push(curr);\n    } else {\n      var indexesToRemove = [];\n      curr.values.forEach(function(e, idx) {\n        if(curr.main.indexOf(e) == -1) {\n          curr.miss++;\n          curr.matched++;\n        } else {\n          indexesToRemove.push(idx);\n          curr.matched++;\n        }\n      });\n      // remove all the items we have matched from the values\n      indexesToRemove.forEach(function(idx) {\n        curr.values.splice(idx, 1);\n      })\n      curr.missmatches = curr.miss + (curr.main.length - curr.matched);\n      if(curr.missmatches != 0) {\n        res.push(curr);\n      }\n    }\n  }\n  return res;\n}"}}}, "meta": {"rev": "96-598a1880", "id": "_design/dev_conflict"}}}]